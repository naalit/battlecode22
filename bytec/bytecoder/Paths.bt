extern {
    package bytecoder;
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

let target: MapLocation;

let closest_archon: MapLocation;
fn findArchon() {
    let loc = rc.getLocation();
    for i in rc.senseNearbyRobots() {
        if i.type == RobotType::ARCHON {
            if closest_archon == null || i.location.distanceSquaredTo(loc) < closest_archon.distanceSquaredTo(loc) {
                closest_archon = i.location;
            }
        }
    }
}

fn targetMove(exploring: bool): bool throws GameActionException {
    let loc = rc.getLocation();

    if (target == null || target == loc || (exploring && rc.canSenseLocation(target) && !rc.onTheMap(target))) {
        if exploring {
            retarget();
        } else {
            return false;
        }
    }

    rc.setIndicatorLine(loc, target, 0, 255, 0);

    let dir = loc.dirTo(target);

    if closest_archon == null {
        findArchon();
    }
    let too_close = closest_archon != null && loc.isWithinDistanceSquared(closest_archon, 2);

    // Try going around obstacles, first left, then right
    let options = [ loc.add(dir), loc.add(dir.rotateLeft()), loc.add(dir.rotateRight()),
        loc.add(dir.rotateLeft().rotateLeft()), loc.add(dir.rotateRight().rotateRight()) ];
    let best: MapLocation = null;
    let best_pass = 100;
    let prev_dist2 = loc.distanceSquaredTo(target);
    for i in options {
        // Don't occupy archon spawning spaces
        if (closest_archon != null && !too_close && i.isWithinDistanceSquared(closest_archon, 2)) || !rc.canMove(loc.dirTo(i)) {
            continue;
        }

        if i == target {
            best = i;
            best_pass = -1;
        } else if rc.senseRubble(i) < best_pass
            && (too_close || i.isWithinDistanceSquared(target, prev_dist2 - 1)) {
            best = i;
            best_pass = rc.senseRubble(i);
        }
    }
    // It's better to move in a bad direction than not move at all
    if (best == null && rc.isMovementReady()) {
        if (exploring) {
            retarget();
            return targetMove(false);
        }
        // This isn't used right now, but we might want to try removing the others from options and adding this back in
        // else {
        //     let others = [ loc.add(dir.rotateLeft().rotateLeft()), loc.add(dir.rotateRight().rotateRight()) ];
        //     for i in others {
        //         // Don't occupy EC spawning spaces
        //         if (closest_archon != null && i.isWithinDistanceSquared(closest_archon, 2)) || !rc.canMove(loc.dirTo(i)) {
        //             continue;
        //         }
        // 
        //         if rc.senseRubble(i) > best_pass {
        //             best = i;
        //             best_pass = rc.senseRubble(i);
        //         }
        //     }
        // }
    }
    if (best == null) {
        false
    } else {
        dir = loc.dirTo(best);

        rc.move(dir);
        true
    }
}

let retarget_acc = 0;

fn retarget() {
    if retarget_acc == 0 {
        retarget_acc = rc.getID();
    }

    let width = rc.getMapWidth();
    let height = rc.getMapHeight();

    let wxh = width * height;
    // This is a RNG technique I found online called Linear Congruential Generator
    // This should be a random 12 bits
    retarget_acc = (1231 * retarget_acc + 3171) % wxh;
    // Split into two, each in 0..N
    let x = retarget_acc % width;
    let y = retarget_acc / width;

    target = MapLocation(x, y);
}