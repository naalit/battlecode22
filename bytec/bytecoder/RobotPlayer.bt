extern {
    package bytecoder;
    import battlecode.common.*;

    import java.util.Random;
}

use Common::*;

extern class Random {
    constructor(seed: i32);
    fn nextInt(max: i32): i32;
    fn nextBool(): bool = "nextBoolean";
}

let turnCount = 0;
let rng = Random(12);
let directions = [
    Direction::NORTH,
    Direction::NORTHEAST,
    Direction::EAST,
    Direction::SOUTHEAST,
    Direction::SOUTH,
    Direction::SOUTHWEST,
    Direction::WEST,
    Direction::NORTHWEST,
];
let team: Team;

let rc: RobotController;

fn pub run(rc2: RobotController) {
    rc = rc2;
    team = rc.getTeam();
    loop {
        extern "try {";

        match rc.getType() {
            ARCHON => runArchon(),
            MINER => runMiner(),
            SOLDIER => runSoldier(),
            else => {},
        }

        extern "} catch (Exception e) { e.printStackTrace(); }";
        clockYield();
    }
}

fn runArchon() throws GameActionException {
    if rc.getRoundNum() == 1 {
        rc.buildRobot(RobotType::MINER, Direction::SOUTH);
    } else if rc.getRoundNum() < 200 && rc.getTeamLeadAmount(team) > RobotType::MINER.buildCostLead * rc.getArchonCount() {
        for dir in directions {
            if rc.canBuildRobot(RobotType::MINER, dir) {
                rc.buildRobot(RobotType::MINER, dir);
            }
        }
    } else {
        let dir = directions[rng.nextInt(directions.len())];
        if rng.nextBool() {
            if rc.canBuildRobot(RobotType::MINER, dir) {
                rc.buildRobot(RobotType::MINER, dir);
            }
        } else {
            if rc.canBuildRobot(RobotType::SOLDIER, dir) {
                rc.buildRobot(RobotType::SOLDIER, dir);
            }
        }
    }
}

fn runMiner() throws GameActionException {
    // Mine
    let at = rc.getLocation();
    let some_left = false;
    for dx in -1..1 {
        for dy in -1..1 {
            let loc = at.translate(dx, dy);
            while rc.canMineGold(loc) {
                rc.mineGold(loc);
            }
            // Leave 1 so it regenerates
            while rc.canMineLead(loc) && rc.senseLead(loc) > 1 {
                rc.mineLead(loc);
            }
            if !some_left && rc.canSenseLocation(loc) && (rc.senseLead(loc) > 1 || rc.senseGold(loc) > 0) {
                some_left = true;
            }
        }
    }

    // Move, if we're done mining
    if !some_left {
        // If we can see any metals, go mine them
        let best_lead = 1;
        let best_loc: MapLocation = null;
        for l in rc.getAllLocationsWithinRadiusSquared(at, rc.getType().visionRadiusSquared) {
            if rc.canSenseLocation(l) {
                let lead = rc.senseLead(l) + rc.senseGold(l) * 50;
                if lead > best_lead {
                    best_lead = lead;
                    best_loc = l;
                }
            }
        }

        if best_loc != null {
            Paths::target = best_loc;
        }
        Paths::targetMove(true);
    }
}

fn runSoldier() throws GameActionException {
    let loc = rc.getLocation();

    let radius = rc.getType().actionRadiusSquared;
    let opponent = rc.getTeam().opponent();
    let enemies = rc.senseNearbyRobotsT(rc.getType().visionRadiusSquared, opponent);

    // We attack the enemy with the lowest hp in attack range, and if we can see
    // enemies outside of attack range we move towards the one of those with the lowest hp
    // The idea is to kill more units more quickly which is better than just doing damage
    let attack_hp = 10000;
    let attack_target: MapLocation = null;
    let move_hp = 10000;
    let move_target: MapLocation = null;
    for i in enemies {
        if i.location.isWithinDistanceSquared(loc, radius) {
            if i.health < attack_hp {
                attack_hp = i.health;
                attack_target = i.location;
            }
        } else {
            if i.health < move_hp {
                move_hp = i.health;
                move_target = i.location;
            }
        }
    }

    // Attack
    if attack_target != null {
        if rc.canAttack(attack_target) {
            rc.attack(attack_target);
        }
    }

    // Move
    if move_target != null {
        Paths::target = move_target;
    }
    Paths::targetMove(true);
}
