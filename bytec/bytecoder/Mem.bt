extern {
    package bytecoder;
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

// Cache these, 200 bytecode is better than splitting it manually but we definitely don't want to do it twice
let nearbyRobotsMe: [RobotInfo] = [];
let nearbyRobotsThem: [RobotInfo] = [];

// Run this once a turn, before doing other things.
// It caches nearby robots, communicates stuff it found, etc.
let max_btc = 0;
let tot_btc = 0;
let maintain_count = 0;
fn maintain() throws GameActionException {
    let start_btc = bytecodeNum();

    let visRadius = rc.getType().visionRadiusSquared;
    nearbyRobotsMe = rc.senseNearbyRobotsT(visRadius, rc.getTeam());
    nearbyRobotsThem = rc.senseNearbyRobotsT(visRadius, rc.getTeam().opponent());

    readCmds();

    readArchons();
    searchArchons();

    let end_btc = bytecodeNum();
    let btc = end_btc - start_btc;
    maintain_count += 1;
    tot_btc += btc;
    if btc > max_btc {
        max_btc = btc;
    }
    // rc.setIndicatorString("Max maintain() btc: " + max_btc + ", avg: " + tot_btc / maintain_count);
}

// A location takes up 12 bits
// ...this is a lot easier than last year
fn encodeLoc(loc: MapLocation): i32 = (loc.y << 6) | loc.x;
fn decodeLoc(x: i32): MapLocation = MapLocation(x & 0b111111, (x >> 6) & 0b111111);

let ARCHON_LOC = 0;
let CMD_LOC = 16;
fn cmdLoc(): i32 throws GameActionException {
    CMD_LOC + 16 * (rc.getRoundNum() % 2)
}
fn cmdLocOther(): i32 throws GameActionException {
    CMD_LOC + 16 * ((rc.getRoundNum() + 1) % 2)
}
let AVAILABLE_SOLDIERS = 15;

fn getAvailableSoldiers(): i32 throws GameActionException {
    rc.readSharedArray(AVAILABLE_SOLDIERS)
}
fn clearAvailableSoldiers() throws GameActionException {
    rc.writeSharedArray(AVAILABLE_SOLDIERS, 0);
}
fn addAvailableSoldier() throws GameActionException {
    rc.writeSharedArray(AVAILABLE_SOLDIERS, rc.readSharedArray(AVAILABLE_SOLDIERS) + 1);
}

enum Cmd {
    Attack(MapLocation),
    Protect(MapLocation),
    EndAttack;

    // 0000 000000000000
    // ^- type     ^- location or other payload
    fn encode(): i32 = match self {
        Attack(l) => (1 << 14) | encodeLoc(l),
        EndAttack => 2 << 14,
        Protect(l) => (3 << 14) | encodeLoc(l),
    };

    fn toString(): str = match self {
        Attack(l) => "Attack(" + l + ")",
        EndAttack => "EndAttack",
        Protect(l) => "Protect(" + l + ")",
    };
}
// TODO static methods
fn decodeCmd(x: i32): Cmd {
    let tag = x >> 14;
    if tag == 1 {
        Cmd::Attack(decodeLoc(x))
    } else if tag == 2 {
        Cmd::EndAttack
    } else if tag == 3 {
        Cmd::Protect(decodeLoc(x))
    } else {
        // TODO don't require this for type inference
        let cmd: Cmd = null;
        cmd
    }
}
fn pushCmd(cmd: Cmd) throws GameActionException {
    let i = cmdLoc();
    while rc.readSharedArray(i) != 0 {
        i += 1;
    }
    if i > cmdLoc() + 16 {
        println("Warning: Too many commands, skipping " + cmd.toString());
        return;
    }
    rc.writeSharedArray(i, cmd.encode());
    rc.writeSharedArray(i+1, 0);
}
let commands: [Cmd] = [];
let commandsLast: [Cmd] = [];
fn readCmds() throws GameActionException {
    commands.clear();
    let i = cmdLoc();
    loop {
        let cmdi = rc.readSharedArray(i);
        if cmdi == 0 || i > cmdLoc() + 16 {
            break;
        }
        let cmd = decodeCmd(cmdi);
        if cmd == null {
            println("Warning: Could not decode cmd " + cmdi);
        } else {
            commands.push(cmd);
        }
        i += 1;
    }

    if rc.getType() == RobotType::ARCHON {
        commandsLast.clear();
        let i = cmdLocOther();
        loop {
            let cmdi = rc.readSharedArray(i);
            if cmdi == 0 || i > cmdLocOther() + 16 {
                break;
            }
            let cmd = decodeCmd(cmdi);
            if cmd == null {
                println("Warning: Could not decode cmd " + cmdi);
            } else {
                commandsLast.push(cmd);
            }
            i += 1;
        }
    }
}
fn clearCmds() throws GameActionException {
    commands.clear();
    if rc.readSharedArray(cmdLoc()) != 0 {
        rc.writeSharedArray(cmdLoc(), 0);
    }
}

// Just enemy archons, for now
let archons: [MapLocation] = [];
fn readArchons() throws GameActionException {
    let a = rc.readSharedArray(ARCHON_LOC);
    // 4-bit number of enemy archons we know of
    let numArchons = a >> 12;
    if numArchons != archons.len() {
        archons = [];
        for i in 0..numArchons {
            let n = rc.readSharedArray(ARCHON_LOC + i);
            archons.push(decodeLoc(n));
        }
    }
}
fn pushArchon(loc: MapLocation) throws GameActionException {
    rc.setIndicatorLine(rc.getLocation(), loc, 255, 0, 0);

    archons.push(loc);
    let a = rc.readSharedArray(ARCHON_LOC);
    let oldNum = a >> 12;
    // Don't incur the 100 btc cost twice unless we need to
    if oldNum == 0 {
        let a = ((oldNum + 1) << 12) | encodeLoc(loc);
        rc.writeSharedArray(ARCHON_LOC, a);
    } else {
        // Just do the addition on the high bits directly
        a += 1 << 12;
        rc.writeSharedArray(ARCHON_LOC, a);
        rc.writeSharedArray(ARCHON_LOC + oldNum, encodeLoc(loc));
    }
}
fn removeArchon(i: i32) throws GameActionException {
    rc.setIndicatorLine(rc.getLocation(), archons[i], 127, 0, 127);

    // Easy case
    if archons.len() == 1 {
        // TODO we shouldn't need the `let _`
        let _ = archons.pop();
        rc.writeSharedArray(0, 0);
        return;
    }

    // Swap the removed element with the last element so only touch those two
    // (and we don't even have to touch the last element in the shared array)
    let last_loc = archons.pop();
    archons[i] = last_loc;
    if i == 0 {
        rc.writeSharedArray(0, (archons.len() << 12) | encodeLoc(last_loc));
    } else {
        let a = rc.readSharedArray(0);
        a -= 1 << 12;
        rc.writeSharedArray(0, a);
        rc.writeSharedArray(i, encodeLoc(last_loc));
    }
}
fn searchArchons() throws GameActionException {
    fn seenArchon(loc: MapLocation): bool {
        for i in archons {
            if i == loc {
                return true;
            }
        }
        false
    }

    // Find new archons
    for i in nearbyRobotsThem {
        if i.type == RobotType::ARCHON && !seenArchon(i.location) {
            pushArchon(i.location);
        }
    }
    // Remove ones that no longer exist
    let remove: [i32] = [];
    for i in 0..archons.len() {
        if archons[i].isWithinDistanceSquared(rc.getLocation(), rc.getType().visionRadiusSquared) {
            let r = rc.senseRobotAtLocation(archons[i]);
            if r == null || r.type != RobotType::ARCHON {
                remove.push(i);
            }
        }
    }
    for i in remove {
        removeArchon(i);
    }
}