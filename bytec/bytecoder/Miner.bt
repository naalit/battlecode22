extern {
    package bytecoder;
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

fn runMiner() throws GameActionException {
    // MINER MICRO:
    // 1. Mine as much as we can right now, that's the only thing the action cooldown is for
    // 2. Move:
    //   a. If there's more metal to mine without moving, stay here
    //   b. If there are enemy soldiers nearby, move away from them
    //   c. If we can see metal that we can mine somewhere else, go there
    //   d. Explore randomly
    // 3. Try to mine again if we moved

    if tryMine() {
        return;
    }

    // If there are enemy soldiers nearby, run away
    // Temporarily disabled because it's often harmful on small maps
    let loc = rc.getLocation();
    // let closest_soldier: MapLocation = null;
    // let closest_d = 1000;
    // for i in Mem::nearbyRobotsThem {
    //     if i.type == RobotType::SOLDIER {
    //         let d = i.location.distanceSquaredTo(loc);
    //         if d < closest_d {
    //             closest_soldier = i.location;
    //             closest_d = d;
    //         }
    //     }
    // }
    // if closest_soldier != null {
    //     rc.setIndicatorLine(loc, closest_soldier, 255, 0, 0);
    //     let dirAway = closest_soldier.dirTo(loc);
    //     Paths::target = loc.add(dirAway).add(dirAway);
    // } else {
        // If we can see any metals, go mine them
        let start_turn = rc.getRoundNum();
        let best_lead = 0;
        let found_gold = false;
        let best_score = 10000;
        let best_loc: MapLocation = null;
        for l in rc.senseNearbyLocationsWithGold(rc.getType().visionRadiusSquared) {
            found_gold = true;
            let lead = rc.senseLead(l) + rc.senseGold(l) * 50;
            if lead > best_lead {
                best_lead = lead;
                best_loc = l;
            }
        }
        // TODO prioritize gold once we actually use it
        // if !found_gold {
        let dirs: [Direction] = [Direction::NORTH, Direction::NORTH, Direction::NORTH];
        for l in rc.senseNearbyLocationsWithLead(rc.getType().visionRadiusSquared) {
            if bytecodeLeft() < 2000 {
                // If there are that many locations with lead, it doesn't matter too much where we go anyway
                break;
            }
            let lead = rc.senseLead(l) + rc.senseGold(l) * 50;
            if best_lead == 0 {
                best_lead = lead;
                best_loc = l;
            }
            let dist = loc.distanceSquaredTo(l);
            if lead > 1 && dist <= best_score + 5 {
                let pub dirTo = l.dirTo(loc);
                dirs[0] = dirTo;
                dirs[1] = dirTo.rotateLeft();
                dirs[2] = dirTo.rotateRight();
                for dir in dirs {
                    let l2 = l.add(dir);
                    if !rc.canSenseLocation(l2) || !rc.onTheMap(l2) {
                        continue;
                    }
                    let dist = loc.distanceSquaredTo(l2);
                    let pass = rc.senseRubble(l2);
                    let score = dist + pass;
                    if score < best_score
                        || (score == best_score && lead < best_lead) {
                        best_lead = lead;
                        best_loc = l2;
                        best_score = score;
                    }
                }
            }
        }

        if best_lead > 1 {
            Paths::target = best_loc;
        } else if best_lead == 1 && rc.getRoundNum() > 40 {
            // If lead will regenerate, make sure there's a miner by it
            let isMiner = false;
            for i in Mem::nearbyRobotsMe {
                if i.type == RobotType::MINER {
                    isMiner = true;
                    break;
                }
            }
            if !isMiner {
                Paths::target = best_loc;
            }
        }
    // }
    if rc.getRoundNum() != start_turn {
        println("Miner targeting overflowed bytecode by " + bytecodeNum() + " btc");
    }
    if best_loc == null || loc != best_loc {
        Paths::targetMove(true);
    }

    tryMine();
}

// Returns whether we can continue mining this spot next turn
fn tryMine(): bool throws GameActionException {
    let at = rc.getLocation();
    let some_left = false;
    for dir in RobotPlayer::directions {
        let loc = at.add(dir);
        while rc.canMineGold(loc) {
            rc.mineGold(loc);
        }
        // Leave 1 so it regenerates
        while rc.canMineLead(loc) && rc.senseLead(loc) > 1 {
            rc.mineLead(loc);
        }
        if !some_left && rc.canSenseLocation(loc) && (rc.senseLead(loc) > 1 || rc.senseGold(loc) > 0) {
            some_left = true;
        }
    }
    some_left
}