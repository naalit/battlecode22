extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

fn runMiner() throws GameActionException {
    // MINER MICRO:
    // 1. Mine as much as we can right now, that's the only thing the action cooldown is for
    // 2. Move:
    //   a. If there's more metal to mine without moving, stay here
    //   b. If there are enemy soldiers nearby, move away from them
    //   c. If we can see metal that we can mine somewhere else, go there
    //   d. Explore randomly
    // 3. Try to mine again if we moved

    let stay_loc = tryMine();

    // If there are enemy soldiers nearby, run away
    // Temporarily disabled because it's often harmful on small maps
    let loc = rc.getLocation();
    let closest_soldier: MapLocation = null;
    let closest_d = 1000;
    for i in Mem::nearbyRobotsThem {
        if i.type == RobotType::SOLDIER {
            let d = i.location.distanceSquaredTo(loc);
            if d < closest_d {
                closest_soldier = i.location;
                closest_d = d;
            }
        }
    }
    if closest_soldier != null {
        rc.setIndicatorLine(loc, closest_soldier, 255, 0, 0);
        let dirAway = closest_soldier.dirTo(loc);
        Paths::target = loc.add(dirAway).add(dirAway);
        Paths::targetMove(false);
    } else if stay_loc != null {
        let best_pass = 10000;
        let best_d = 10000;
        let best_loc: MapLocation = null;
        for dir in RobotPlayer::directions {
            let l = stay_loc.add(dir);
            if rc.canSenseLocation(l) && rc.onTheMap(l) {
                let pass = rc.senseRubble(l);
                let d = loc.distanceSquaredTo(l);
                if pass < best_pass || (pass == best_pass && d < best_d) {
                    d = best_d;
                    best_pass = pass;
                    best_loc = l;
                }
            }
        }
        Paths::target = best_loc;
        Paths::targetMove(false);
    } else {
        // If we can see any metals, go mine them
        let best_lead = 0;
        let found_gold = false;
        let best_loc: MapLocation = null;
        for l in rc.senseNearbyLocationsWithGold(rc.getType().visionRadiusSquared) {
            found_gold = true;
            let lead = rc.senseLead(l) + rc.senseGold(l) * 50;
            if lead > best_lead {
                best_lead = lead;
                best_loc = l;
            }
        }
        for l in rc.senseNearbyLocationsWithLead(rc.getType().visionRadiusSquared, 2) {
            rc.setIndicatorLine(loc, l, 0, 0, 255);
            found_gold = true;
            let lead = rc.senseLead(l) + rc.senseGold(l) * 50;
            if lead > best_lead {
                best_lead = lead;
                best_loc = l;
            }
        }

        if best_loc != null {
            Paths::target = best_loc;
        }
        Paths::targetMove(true);
    }

    tryMine();
}

// Returns whether we can continue mining an adjacent location
fn tryMine(): MapLocation throws GameActionException {
    let at = rc.getLocation();
    let some_left: MapLocation = null;
    for dir in RobotPlayer::directions {
        let loc = at.add(dir);
        while rc.canMineGold(loc) {
            rc.mineGold(loc);
        }
        // Leave 1 so it regenerates
        while rc.canMineLead(loc) && rc.senseLead(loc) > 1 {
            rc.mineLead(loc);
        }
        if some_left == null && rc.canSenseLocation(loc) && (rc.senseLead(loc) > 1 || rc.senseGold(loc) > 0) {
            some_left = loc;
        }
    }
    some_left
}