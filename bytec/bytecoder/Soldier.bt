extern {
    package bytecoder;
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

// We generally try defend this archon
// There is usually only one in range so we only bother with one
let closestArchon: RobotInfo;

let protectTurns = 20;
fn attackTarget(): (RobotInfo, RobotInfo) {
    let loc = rc.getLocation();
    let radius = rc.getType().actionRadiusSquared;

    let near: RobotInfo = null;
    let far: RobotInfo = null;
    for bot in Mem::nearbyRobotsThem {
        let isNear = bot.location.isWithinDistanceSquared(loc, radius);
        let ref = if isNear { near } else { far };
        // Includes soldiers, sages, and watchtowers
        if bot.type.damage > 0 {
            protectTurns = 20;
        }

        // Targeting priority:
        fn priority(ty: RobotType): i32 = match ty {
            // Sages are valuable and dangerous, kill on sight
            SAGE => 7,
            // The most immediate threat, if we don't kill them they'll kill us
            SOLDIER => 6,
            // We'll need to kill these to take out a watchtower
            // probably should have special-case code for actually seeing a watchtower though
            BUILDER => 5,
            // Another threat
            WATCHTOWER => 4,
            // We probably won't take out an Archon anytime soon with Soldiers, but doing damage on it is good
            // Really these last three are TBD though
            ARCHON => 3,
            MINER => 2,
            LABORATORY => 1,
        };

        let better =
                ref == null
            ||  priority(bot.type) > priority(ref.type)
            // Pick the lowest hp to kill more units more quickly, which is better than just doing damage
            ||  bot.health < ref.health
            // Target the one closest to the Archon if there is one
            ||  (closestArchon != null && bot.location.isWithinDistanceSquared(closestArchon.location, closestArchon.location.distanceSquaredTo(ref.location)))
            // Otherwise just pick the closest one
            ||  bot.location.isWithinDistanceSquared(loc, loc.distanceSquaredTo(ref.location));
        if better {
            if isNear {
                near = bot;
            } else {
                far = bot;
            }
        }
    }
    (near, far)
}

let lastProtect: MapLocation = null;
fn runSoldier() throws GameActionException {
    let loc = rc.getLocation();

    closestArchon = null;
    let numSoldiers = 0;
    for i in Mem::nearbyRobotsMe {
        if i.type == RobotType::ARCHON {
            if closestArchon == null || i.location.isWithinDistanceSquared(loc, closestArchon.location.distanceSquaredTo(loc)) {
                closestArchon = i;
            }
        } else if i.type == RobotType::SOLDIER {
            numSoldiers += 1;
        }
    }

    let targets = attackTarget();
    // TODO destructuring
    let attack_target = targets.0;
    let move_target = targets.1;

    // Attack
    if attack_target != null {
        if rc.canAttack(attack_target.location) {
            rc.attack(attack_target.location);
        }
    }

    // Move
    // Defend our Archon if we're not in very early game and we've seen enemies recently
    // If we don't see enemy soldiers for 20 turns, we leave so we don't waste soldiers defending archons that aren't under attack

    let protectStill = false;

    // Go towards an enemy, but don't abandon the archon
    let protect = closestArchon != null && protectTurns > 0 && rc.getRoundNum() > 40;
    if move_target != null && (!protect || closestArchon.location.isWithinDistanceSquared(loc, 13)) {
        Paths::target = move_target.location;
    } else if protect { //&& numSoldiers < (2 + 3 * Mem::nearbyRobotsThem.len()) && rc.getRoundNum() > 100 {
        // Try to stay about 13 units^2 of the archon so we're not in the way
        protectTurns -= 1;
        let r2 = 13;
        let closest: Direction = null;
        let closest_d = 10000;
        for dir in RobotPlayer::directions {
            let arch = closestArchon.location;
            let l = loc.add(dir).add(dir);
            if rc.canMove(dir) && rc.onTheMap(l) {
                let d = l.distanceSquaredTo(arch);
                if (arch.x + 6 * dir.dx > rc.getMapWidth()
                    || arch.y + 6 * dir.dy > rc.getMapHeight()
                    || arch.x - 6 < 0
                    || arch.y - 6 < 0)
                    && d >= loc.distanceSquaredTo(arch) {
                        continue;
                    }
                d = abs(d - r2);
                if (d < closest_d) {
                    closest = dir;
                    closest_d = d;
                }
            }
        }
        if closest != null {
            Paths::target = loc.add(closest);
        }
    } else if Mem::commands.len() > 0 {
        let available = true;
        for i in Mem::commands {
            match i {
                Attack(l) => Paths::target = l,
                EndAttack => Paths::target = null,
                Protect(l) => {
                    protectStill = true;
                    lastProtect = l;
                    Paths::target = l;
                    available = false;
                }
            }
            // break;
        }
        if available {
            Mem::addAvailableSoldier();
        }
    } else {
        Mem::addAvailableSoldier();
    }
    if !protectStill && lastProtect != null {
        if lastProtect == Paths::target {
            Paths::target = null;
        }
        lastProtect = null;
    }
    Paths::targetMove(true);
}