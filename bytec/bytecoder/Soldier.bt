extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

// We generally try defend this archon
// There is usually only one in range so we only bother with one
let closestArchon: RobotInfo;
let nearbyEnemyHP = 0;

let protectTurns = 20;
fn attackTarget(): (RobotInfo, RobotInfo) {
    nearbyEnemyHP = 0;
    let loc = rc.getLocation();
    let radius = rc.getType().actionRadiusSquared;

    let near: RobotInfo = null;
    let far: RobotInfo = null;
    for bot in Mem::nearbyRobotsThem {
        let isNear = bot.location.isWithinDistanceSquared(loc, radius);
        let ref = if isNear { near } else { far };
        // Includes soldiers, sages, and watchtowers
        if bot.type.damage > 0 {
            protectTurns = 20;
            nearbyEnemyHP += bot.health;
        }

        // Targeting priority:
        fn priority(ty: RobotType): i32 = match ty {
            // Sages are valuable and dangerous, kill on sight
            SAGE => 7,
            // The most immediate threat, if we don't kill them they'll kill us
            SOLDIER => 6,
            // We'll need to kill these to take out a watchtower
            // probably should have special-case code for actually seeing a watchtower though
            BUILDER => 5,
            // Another threat
            WATCHTOWER => 4,
            // We probably won't take out an Archon anytime soon with Soldiers, but doing damage on it is good
            // Really these last three are TBD though
            ARCHON => 3,
            MINER => 2,
            LABORATORY => 1,
        };

        let better =
                ref == null
            ||  priority(bot.type) > priority(ref.type)
            // Pick the lowest hp to kill more units more quickly, which is better than just doing damage
            ||  bot.health < ref.health
            // Target the one closest to the Archon if there is one
            ||  (closestArchon != null && bot.location.isWithinDistanceSquared(closestArchon.location, closestArchon.location.distanceSquaredTo(ref.location)))
            // Otherwise just pick the closest one
            ||  bot.location.isWithinDistanceSquared(loc, loc.distanceSquaredTo(ref.location));
        if better {
            if isNear {
                near = bot;
            } else {
                far = bot;
            }
        }
    }
    (near, far)
}

fn runWatchtower() throws GameActionException {
    let targets = attackTarget();
    // TODO destructuring
    let attack_target = targets.0;
    let move_target = targets.1;

    // Attack
    if attack_target != null {
        if rc.canAttack(attack_target.location) {
            rc.attack(attack_target.location);
        }
    }
}

let lastProtect: MapLocation = null;
fn runSoldier() throws GameActionException {
    let loc = rc.getLocation();

    closestArchon = null;
    let nearbyFriendlyHP = rc.getHealth();
    for i in Mem::nearbyRobotsMe {
        if i.type == RobotType::ARCHON {
            if closestArchon == null || i.location.isWithinDistanceSquared(loc, closestArchon.location.distanceSquaredTo(loc)) {
                closestArchon = i;
            }
        } else if i.type.damage > 0 {
            nearbyFriendlyHP += i.health;
        }
    }
    // TODO:
    // We want soldiers to be in groups instead of traveling alone, so that attacking works better.
    // How do we implement that? What's the priority of group cohesion? Is it only in combat mode? (no it isn't)
    // This didn't really work, but I'm not sure how else we would do it.

    // if numSoldiers != 0 {
    //     let soldierCenter = MapLocation(soldierTotX / numSoldiers, soldierTotY / numSoldiers);
    //     rc.setIndicatorDot(soldierCenter, 0, 0, 255);
    //     Paths::attractor = soldierCenter;
    // }

    let targets = attackTarget();
    // TODO destructuring
    let attack_target = targets.0;
    let move_target = targets.1;

    // Attack
    if attack_target != null {
        if rc.canAttack(attack_target.location) {
            rc.attack(attack_target.location);
        }
    }

    // Move
    // Defend our Archon if we're not in very early game and we've seen enemies recently
    // If we don't see enemy soldiers for 20 turns, we leave so we don't waste soldiers defending archons that aren't under attack

    let protectStill = false;

    // Go towards an enemy, but don't abandon the archon
    let protect = closestArchon != null && protectTurns > 0 && rc.getRoundNum() > 40;
    if attack_target != null {
        // Combat mode pathfinding
        // We attack faster on lower rubble tiles
        let curRubble = rc.senseRubble(loc);
        let minRubble = curRubble;
        let minDir = Direction::CENTER;
        let shouldRun = nearbyEnemyHP > nearbyFriendlyHP;
        let bestDist = loc.distanceSquaredTo(attack_target.location);
        for dir in RobotPlayer::directions {
            let new_loc = loc.add(dir);
            if rc.canMove(dir) && (shouldRun || new_loc.isWithinDistanceSquared(attack_target.location, rc.getType().actionRadiusSquared)) {
                let rubble = rc.senseRubble(new_loc);
                if rubble < minRubble {
                    minRubble = rubble;
                    minDir = dir;
                } else if rubble == minRubble {
                    if shouldRun {
                        if new_loc.distanceSquaredTo(attack_target.location) > bestDist {
                            minDir = dir;
                            bestDist = new_loc.distanceSquaredTo(attack_target.location);
                        }
                    } else {
                        if new_loc.distanceSquaredTo(attack_target.location) < bestDist {
                            minDir = dir;
                            bestDist = new_loc.distanceSquaredTo(attack_target.location);
                        }
                    }
                }
            }
        }
        if minDir != Direction::CENTER {
            if rc.canMove(minDir) {
                rc.move(minDir);
            }
        }
        return;
    } else if move_target != null && (!protect || closestArchon.location.isWithinDistanceSquared(loc, 13)) {
        if nearbyEnemyHP > nearbyFriendlyHP {
            // Run away, we'll just die if we stay
            let dirTowards = loc.dirTo(move_target.location);
            Paths::target = loc.sub(dirTowards).sub(dirTowards);
        } else {
            Paths::target = move_target.location;
        }
    } else if protect { //&& numSoldiers < (2 + 3 * Mem::nearbyRobotsThem.len()) && rc.getRoundNum() > 100 {
        // Try to stay about 13 units^2 of the archon so we're not in the way
        protectTurns -= 1;
        let r2 = 13;
        let closest: Direction = null;
        let closest_d = 10000;
        for dir in RobotPlayer::directions {
            let arch = closestArchon.location;
            let l = loc.add(dir).add(dir);
            if rc.canMove(dir) && rc.onTheMap(l) {
                let d = l.distanceSquaredTo(arch);
                if (arch.x + 6 * dir.dx > rc.getMapWidth()
                    || arch.y + 6 * dir.dy > rc.getMapHeight()
                    || arch.x - 6 < 0
                    || arch.y - 6 < 0)
                    && d >= loc.distanceSquaredTo(arch) {
                        continue;
                    }
                d = abs(d - r2);
                if (d < closest_d) {
                    closest = dir;
                    closest_d = d;
                }
            }
        }
        if closest != null {
            Paths::target = loc.add(closest);
        }
    } else if Mem::commands.len() > 0 {
        let available = true;
        for i in Mem::commands {
            match i {
                Attack(l) => Paths::target = l,
                EndAttack => Paths::target = null,
                Protect(l) => {
                    protectStill = true;
                    lastProtect = l;
                    Paths::target = l;
                    available = false;
                }
            }
            // break;
        }
        if available {
            Mem::addAvailableSoldier();
        }
    } else {
        Mem::addAvailableSoldier();
    }
    if !protectStill && lastProtect != null {
        if lastProtect == Paths::target {
            Paths::target = null;
        }
        lastProtect = null;
    }
    Paths::targetMove(true);
}