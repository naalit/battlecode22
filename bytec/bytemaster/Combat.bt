extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

let RETREAT_HEALTH = 15;
define ABYSS_VALUE = 5;
define KILL_VALUE = 20;
let at: MapLocation;
let actionRadius: i32;
let nearbyFriendlyHP: i32;
let nearbyEnemyHP: i32;
let nearbyFriendlyDamage: i32;
let archonInRange = false;
let selfDamage = 0;
let selfHealth = 0;
let canAttack = false;
let isSage = false;

class LocInfo {
    let loc: MapLocation;
    let enemyDamage: i32;
    let rubble: i32;
    let bestEnemy: RobotInfo;
    let distToEnemy: i32;
    let archonDist: i32;
    let chargeHP: i32;
    let furyHP: i32;
    let attackDamage: i32;
    let bestDamage: i32;
    let canMove: bool;

    fn init(loc: MapLocation, canMove: bool) throws GameActionException {
        self.loc = loc;
        self.rubble = rc.senseRubble(loc);
        self.enemyDamage = 0;
        self.distToEnemy = 100000;
        self.chargeHP = 0;
        self.furyHP = 0;
        self.attackDamage = 0;
        self.bestDamage = 0;
        self.canMove = canMove;
        if Mem::closestArchon != null {
            self.archonDist = Mem::closestArchon.distanceSquaredTo(loc);
        }
    }
}
fn locBetter(old: LocInfo, new: LocInfo): bool {
    if old == null {
        true
    // } else if old.rubble > new.rubble + 10 {
    //     true
    } else if new.rubble <= old.rubble + 20 {
        if  canAttack &&
            // new.enemyDamage <= nearbyFriendlyDamage + selfDamage / (10 + new.rubble) && 
            new.bestEnemy != null && 
            (new.enemyDamage == 0 ||
                new.bestEnemy.health * 100 / max(1, selfDamage / (10 + new.rubble)) <= selfHealth * 100 / new.enemyDamage) && 
            new.bestDamage > old.bestDamage
            {
            true
        } else if canAttack &&
            // old.enemyDamage <= nearbyFriendlyDamage + selfDamage / (10 + old.rubble) && 
            old.bestEnemy != null && 
            (old.enemyDamage == 0 ||
                old.bestEnemy.health * 100 / max(1, selfDamage / (10 + old.rubble)) <= selfHealth * 100 / old.enemyDamage) && 
            // old.bestEnemy.health <= selfHealth && 
            old.bestDamage > new.bestDamage
            {
                false
        } else if new.enemyDamage < old.enemyDamage {
            true
        } else if new.enemyDamage == old.enemyDamage {
            if selfHealth <= RETREAT_HEALTH && new.archonDist < old.archonDist {
                true
            } else if new.rubble < old.rubble && new.enemyDamage > 0 {
                true
            } else if new.rubble > old.rubble && new.enemyDamage > 0 {
                false
            } else if new.rubble <= old.rubble + 10 {
                if canAttack && new.bestEnemy != null && new.bestDamage > old.bestDamage {
                    true
                } else if !canAttack || old.bestEnemy == null || new.bestDamage >= old.bestDamage {
                    if new.rubble < old.rubble {
                        true
                    } else if new.rubble > old.rubble {
                        false
                    } else if nearbyFriendlyHP >= nearbyEnemyHP {
                        new.distToEnemy < old.distToEnemy
                    } else {
                        new.distToEnemy > old.distToEnemy
                    }
                }
            } else {
                false
            }
        } else {
            false
        }
    } else {
        false
    }
}

fn microTarget(dmg: i32, add_soldiers: bool): RobotInfo throws GameActionException {
    at = rc.getLocation();
    let best: RobotInfo = null;
    let bestD = 0;
    for i in Mem::nearbyEnemies {
        if add_soldiers && i.type.damage > 0 {
            Mem::addSoldier(i.location);
        }
        if rc.canAttack(i.location) {
            let d = damageValue(dmg, i);
            if d > bestD {
                best = i;
                bestD = d;
            }
        }
    }
    best
}

fn inline damageValue(dmg: i32, unit: RobotInfo): i32 {
    // 3 damage to soldier at 50% health: 150
    // 3 damage to sage at 100% health: 300
    // 3 damage to lab at 50% health: 6
    // 3 damage to miner at 100% health: 1
    let kill = dmg >= unit.health;
    if kill { dmg = unit.health; }
    let mkill = if kill { 1 } else { 0 };
    let healthPercent = unit.health * 100 / unit.type.getMaxHealth(unit.level);
    let mhealth = (150 - healthPercent) / 10;
    dmg *= mhealth;

    match unit.type {
        // Sages are valuable and dangerous, kill on sight
        SAGE => (dmg + mkill * KILL_VALUE) * 20,
        // The most immediate threat, if we don't kill them they'll kill us
        SOLDIER => (dmg + mkill * KILL_VALUE) * 5,
        // We'll need to kill these to take out a watchtower
        // probably should have special-case code for actually seeing a watchtower though
        BUILDER => dmg + mkill * KILL_VALUE,
        // Another threat
        WATCHTOWER => dmg + mkill * KILL_VALUE * 20,
        // Killing an archon would be *incredible*
        ARCHON => dmg + mkill * 1000,
        // Killing the enemy lab is also pretty good
        LABORATORY => dmg / 5 + mkill * KILL_VALUE * 4,
        MINER => dmg / 10 + mkill * KILL_VALUE,
    }
}

fn repairValue(heal: i32, unit: RobotInfo): i32 {
    if unit.health == unit.type.getMaxHealth(unit.level) {
        return 0;
    }
    let isProto = unit.mode == RobotMode::PROTOTYPE;
    let protoMul = if isProto { 1 } else { 0 };
    let mul = match unit.type {
        // Sages are valuable and dangerous, kill on sight
        SAGE => 4,
        // The most immediate threat, if we don't kill them they'll kill us
        SOLDIER => 3,
        // We'll need to kill these to take out a watchtower
        // probably should have special-case code for actually seeing a watchtower though
        BUILDER => 1,
        // Another threat
        WATCHTOWER => if unit.health < 60 && isProto { 1 } else { 4 + 2 * protoMul },
        // Killing an archon would be *incredible*
        ARCHON => 5,
        // Killing the enemy lab is also pretty good
        LABORATORY => if unit.health < 30 { 4 } else { 1 + 4 * protoMul },
        MINER => 1,
    };
    mul * heal * 100 * (unit.type.getMaxHealth(unit.level) - unit.health) / unit.type.getMaxHealth(unit.level)
}

let cloc: LocInfo = null;
let betterLoc: LocInfo = null;
fn microLoc(ty: RobotType, lvl: i32, considerAttack: bool, considerMove: bool, health: i32, include_center: bool, add_soldiers: bool): LocInfo throws GameActionException {
    at = rc.getLocation();
    selfDamage = ty.getDamage(lvl) * 100;// 1000 / ty.actionCooldown;
    actionRadius = ty.actionRadiusSquared;
    selfHealth = health;
    canAttack = considerAttack;
    isSage = ty == RobotType::SAGE;

    let n: LocInfo = null;
    let locs: [LocInfo; 9] = [n,n,n,n,n,n,n,n,n];
    cloc = null;
    let directions = allDirections();
    for i in unroll 0..9 {
        let dir = directions[i];
        let l = at.add(dir);
        if (include_center && dir == Direction::CENTER) || (!rc.canSenseRobotAtLocation(l) && rc.onTheMap(l)) {
            locs[i] = LocInfo();
            locs[i].init(l, considerMove);
            if dir == Direction::CENTER {
                cloc = locs[i];
            }
        }
    }

    nearbyEnemyHP = 0;
    for bot in Mem::nearbyEnemies {
        if rc.canSenseLocation(bot.location) {
            if add_soldiers && bot.type.damage > 0 {
                Mem::addSoldier(bot.location);
                nearbyEnemyHP += bot.health;
            }
            for loc in locs {
                if loc != null {
                    let d = loc.loc.distanceSquaredTo(bot.location);
                    if bot.mode.canAct && bot.type.damage > 0 {
                        // Assume they could move to attack us next turn, but give it a 2/3 chance
                        if d <= bot.type.actionRadiusSquared {
                            let rubble = rc.senseRubble(bot.location);
                            loc.enemyDamage += (bot.type.getDamage(bot.level) * 1000 / bot.type.actionCooldown) / (10 + rubble);
                        } else {
                            let towardsLoc = bot.location.add(bot.location.dirTo(loc.loc));
                            if towardsLoc.isWithinDistanceSquared(loc.loc, bot.type.actionRadiusSquared) {
                                let rubble = rc.senseRubble(bot.location.add(bot.location.dirTo(loc.loc)));
                                loc.enemyDamage += (bot.type.getDamage(bot.level) * 1000 / bot.type.actionCooldown) / (10 + rubble) * 2 / 3;
                            }
                        }
                    }
                    if canAttack && d <= actionRadius {
                        let attackDamage = damageValue(ty.getDamage(lvl), bot);
                        if attackDamage > loc.attackDamage {
                            loc.bestEnemy = bot;
                            loc.distToEnemy = d;
                            loc.attackDamage = attackDamage;
                            if attackDamage > loc.bestDamage {
                                loc.bestDamage = attackDamage;
                            }
                        }
                        if isSage {
                            if bot.mode == RobotMode::TURRET {
                                let hp = bot.type.getMaxHealth(bot.level) / 10;
                                loc.furyHP += damageValue(hp, bot);
                                if loc.furyHP > loc.bestDamage {
                                    loc.bestDamage = loc.furyHP;
                                }
                            } else if bot.mode == RobotMode::DROID {
                                let hp = bot.type.getMaxHealth(bot.level) * 22 / 100;
                                loc.chargeHP += damageValue(hp, bot);
                                if loc.chargeHP > loc.bestDamage {
                                    loc.bestDamage = loc.chargeHP;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    nearbyFriendlyHP = rc.getHealth();
    nearbyFriendlyDamage = 0;
    for i in Mem::nearbyAllies {
        if rc.canSenseLocation(i.location) {
            if i.type.damage > 0 {
                nearbyFriendlyHP += i.health;
                let rubble = rc.senseRubble(i.location);
                nearbyFriendlyDamage += (i.type.getDamage(i.level) * 1000 / i.type.actionCooldown) / (10 + rubble);
            }
            // Fury also hits friendly buildings
            if isSage && i.mode == RobotMode::TURRET {
                for loc in locs {
                    if loc != null && i.location.isWithinDistanceSquared(loc.loc, actionRadius) {
                        let hp = i.type.getMaxHealth(i.level) / 10;
                        loc.furyHP -= damageValue(hp, i);
                        loc.bestDamage = max(loc.attackDamage, max(loc.furyHP, loc.chargeHP));
                    }
                }
            }
        }
    }

    let best: LocInfo = cloc;
    betterLoc = cloc;
    for loc in locs {
        if loc != null {
            if locBetter(betterLoc, loc) {
                betterLoc = loc;
            }
            if loc.canMove && (best == null || !best.canMove || locBetter(best, loc)) {
                best = loc;
            }
        }
    }
    best
}

fn findSpawnSpace(ty: RobotType): Direction throws GameActionException {
    let best = microLoc(ty, 1, true, true, ty.health, false, false);

    if best != null {
        rc.setIndicatorString("SPAWN MICRO for " + ty + ": Damage: " + best.enemyDamage + ", rubble: " + best.rubble);
        at.dirTo(best.loc)
    } else {
        let n: Direction = null;
        n
    }
}

fn combatMicro() throws GameActionException {
    let best = microLoc(rc.getType(), rc.getLevel(), rc.isActionReady(), rc.isMovementReady(), rc.getHealth(), true, true);
    rc.setIndicatorString("MOVE MICRO: Damage: " + best.enemyDamage + ", rubble: " + best.rubble + " v " + best.bestDamage + "; better v " + betterLoc.bestDamage);
    rc.setIndicatorLine(rc.getLocation(), betterLoc.loc, 127, 127, 127);
    if betterLoc.bestEnemy != null {
        rc.setIndicatorLine(betterLoc.loc, betterLoc.bestEnemy.location, 0, 0, 0);
    }
    if best == null {
        println("ERROR! best should not be null, CENTER is always an option");
    }
    // We can attack before or after moving, do whichever one is better
    let waitAttack = (isSage || best.rubble > 20) && (betterLoc.bestDamage > best.bestDamage || (betterLoc.bestDamage == best.bestDamage && betterLoc.rubble < best.rubble));
    let bestNow = cloc.bestEnemy;
    let bestThen = best.bestEnemy;
    let shouldAttack = true;
    let abyssValue = 0;
    if isSage {
        // Abyss is turned off for now because it kept losing
        ifdef ABYSS_VALUE
        if Miner::shouldOffensiveMine() {
            abyssValue = rc.senseNearbyLocationsWithLeadAt(best.loc, rc.getType().actionRadiusSquared, 2).len() + 7 * rc.senseNearbyLocationsWithGoldAt(best.loc, rc.getType().actionRadiusSquared).len();
            abyssValue *= ABYSS_VALUE;
        }
        shouldAttack = best.attackDamage > max(best.furyHP, best.chargeHP) && best.attackDamage > abyssValue;
    }
    if !waitAttack && shouldAttack && bestNow != null && cloc.bestDamage > best.bestDamage {
        if bestNow != null && rc.canAttack(bestNow.location) {
            rc.attack(bestNow.location);
        }
    }
    if best.loc != at {
        rc.move(at.dirTo(best.loc));
    }
    if rc.isActionReady() && !waitAttack {
        let visRadius = rc.getType().visionRadiusSquared;
        let units = rc.senseNearbyRobotsT(visRadius, rc.getTeam().opponent());
        for i in units {
            // We couldn't see it last turn
            if !i.location.isWithinDistanceSquared(at, visRadius) {
                let damage = damageValue(selfDamage, i);
                if damage > best.bestDamage {
                    if i.location.isWithinDistanceSquared(at, rc.getType().actionRadiusSquared) {
                        bestThen = i;
                        best.bestDamage = damage;
                    }
                    // } else if (isSage || best.rubble > 20) {
                    //     waitAttack = true;
                    // }
                    // break;
                }
            }
        }
    }
    if !waitAttack && shouldAttack && bestThen != null && rc.canAttack(bestThen.location) {
        rc.attack(bestThen.location);
    }
    if isSage && !waitAttack && !shouldAttack && rc.isActionReady() && max(best.furyHP, best.chargeHP) > 0 {
        if abyssValue > best.furyHP && abyssValue > best.chargeHP {
            rc.envision(AnomalyType::ABYSS);
        } else if best.furyHP > best.chargeHP {
            rc.envision(AnomalyType::FURY);
        } else {
            rc.envision(AnomalyType::CHARGE);
        }
    }
}