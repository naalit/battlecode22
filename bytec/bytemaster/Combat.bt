extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;
use Micro::Comparison;

let RETREAT_HEALTH = 15;
define ABYSS_VALUE = 5;
let micro = Micro::Micro().init([
    Comparison::Rubble(20),
    Comparison::AttackPush,
    Comparison::EnemyDamage,
    Comparison::Retreat(RETREAT_HEALTH),
    Comparison::DamageRubble,
    Comparison::Rubble(10),
    Comparison::Attack,
    Comparison::Rubble(0),
    Comparison::PushOrRetreat,
]);

fn microTarget(dmg: i32, add_soldiers: bool): RobotInfo throws GameActionException {
    let best: RobotInfo = null;
    let bestD = 0;
    for i in Mem::nearbyEnemies {
        if add_soldiers && i.type.damage > 0 {
            Mem::addSoldier(i.location);
        }
        if rc.canAttack(i.location) {
            let d = Micro::damageValue(dmg, i);
            if d > bestD {
                best = i;
                bestD = d;
            }
        }
    }
    best
}

fn findSpawnSpace(ty: RobotType): Direction throws GameActionException {
    micro.startSpawn(ty);
    micro.updateEnemies();
    micro.updateAllies();
    let best = micro.bestLoc();

    if best != null {
        rc.setIndicatorString("SPAWN MICRO for " + ty + ": Damage: " + best.enemyDamage + ", rubble: " + best.rubble);
        rc.getLocation().dirTo(best.loc)
    } else {
        let n: Direction = null;
        n
    }
}

fn combatMicro() throws GameActionException {
    micro.startRc(true);
    micro.updateEnemies();
    micro.updateAllies();
    let best = micro.bestLoc();
    let at = rc.getLocation();

    rc.setIndicatorString("MOVE MICRO: Damage: " + best.enemyDamage + ", rubble: " + best.rubble + " v " + best.bestDamage);
    // rc.setIndicatorLine(rc.getLocation(), betterLoc.loc, 127, 127, 127);
    // if betterLoc.bestEnemy != null {
    //     rc.setIndicatorLine(betterLoc.loc, betterLoc.bestEnemy.location, 0, 0, 0);
    // }
    if best == null {
        println("ERROR! best should not be null, CENTER is always an option");
    }
    // We can attack before or after moving, do whichever one is better
    let waitAttack = false;//(isSage || best.rubble > 20) && (betterLoc.bestDamage > best.bestDamage || (betterLoc.bestDamage == best.bestDamage && betterLoc.rubble < best.rubble));
    let bestNow = micro.cloc.bestEnemy;
    let bestThen = best.bestEnemy;
    let shouldAttack = true;
    let abyssValue = 0;
    if micro.canEnvision {
        // Abyss is turned off for now because it kept losing
        ifdef ABYSS_VALUE
        if Miner::shouldOffensiveMine() {
            abyssValue = rc.senseNearbyLocationsWithLeadAt(best.loc, rc.getType().actionRadiusSquared, 2).len() + 7 * rc.senseNearbyLocationsWithGoldAt(best.loc, rc.getType().actionRadiusSquared).len();
            abyssValue *= ABYSS_VALUE;
        }
        shouldAttack = best.attackDamage > max(best.furyHP, best.chargeHP) && best.attackDamage > abyssValue;
    }
    if !waitAttack && shouldAttack && bestNow != null && micro.cloc.bestDamage > best.bestDamage {
        if bestNow != null && rc.canAttack(bestNow.location) {
            rc.attack(bestNow.location);
        }
    }
    if best.loc != at {
        rc.move(at.dirTo(best.loc));
    }
    if rc.isActionReady() && !waitAttack {
        let visRadius = rc.getType().visionRadiusSquared;
        let units = rc.senseNearbyRobotsT(visRadius, rc.getTeam().opponent());
        for i in units {
            // We couldn't see it last turn
            if !i.location.isWithinDistanceSquared(at, visRadius) {
                let damage = Micro::damageValue(micro.damage, i);
                if damage > best.bestDamage {
                    if i.location.isWithinDistanceSquared(at, rc.getType().actionRadiusSquared) {
                        bestThen = i;
                        best.bestDamage = damage;
                    }
                    // } else if (isSage || best.rubble > 20) {
                    //     waitAttack = true;
                    // }
                    // break;
                }
            }
        }
    }
    if !waitAttack && shouldAttack && bestThen != null && rc.canAttack(bestThen.location) {
        rc.attack(bestThen.location);
    }
    if micro.canEnvision && !waitAttack && !shouldAttack && rc.isActionReady() && max(best.furyHP, best.chargeHP) > 0 {
        if abyssValue > best.furyHP && abyssValue > best.chargeHP {
            rc.envision(AnomalyType::ABYSS);
        } else if best.furyHP > best.chargeHP {
            rc.envision(AnomalyType::FURY);
        } else {
            rc.envision(AnomalyType::CHARGE);
        }
    }
}