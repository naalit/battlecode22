extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

fn preTurn() throws GameActionException {

}

class LocInfo {
    let loc: MapLocation;
    let enemyDamage: i32;
    let rubble: i32;
    let repairTarget: RobotInfo;
    let upgradeTarget: RobotInfo;
    let repairValue: i32;

    fn init(loc: MapLocation) throws GameActionException {
        self.loc = loc;
        self.rubble = rc.senseRubble(loc);
        self.enemyDamage = 0;
        self.repairTarget = null;
        self.upgradeTarget = null;
        self.repairValue = 0;
    }
}
fn locBetter(old: LocInfo, new: LocInfo): bool {
    if old == null { return true; }
    // TODO change the way this works so we spawn watchtowers close to the front line
    if new.enemyDamage < old.enemyDamage { return true; }
    if new.enemyDamage > old.enemyDamage { return false; }
    if new.rubble <= old.rubble + 20 {
        if new.repairValue > old.repairValue { return true; }
        if new.repairValue < old.repairValue { return false; }
    }
    new.rubble < old.rubble
}

let cloc: LocInfo = null;
let existsDamage = false;
fn microLoc(include_center: bool, include_others: bool): LocInfo throws GameActionException {
    let at = rc.getLocation();
    Combat::at = at;
    existsDamage = false;
    let n: LocInfo = null;
    towerUpgrade = null;
    let towerRubble = 10000;
    let locs: [LocInfo; 9] = [n,n,n,n,n,n,n,n,n];
    cloc = null;
    let directions = allDirections();
    for i in unroll 0..9 {
        let dir = directions[i];
        let l = at.add(dir);
        if (include_center && dir == Direction::CENTER) || (include_others && !rc.canSenseRobotAtLocation(l) && rc.onTheMap(l)) {
            locs[i] = LocInfo();
            locs[i].init(l);
            if dir == Direction::CENTER {
                cloc = locs[i];
            }
        }
    }
    for i in unroll ENEMY_SOLDIER_LOC..ENEMY_SOLDIER_LOC+ENEMY_SOLDIER_LEN {
        let r = rc.readSharedArray(i);
        if r != 0 {
            let loc = Mem::decodeLoc(r - 1);
            if !loc.isWithinDistanceSquared(at, 20) {
                for l in locs {
                    // Assume enemy soldiers we can't see could have moved 1 tile by now
                    if l != null && loc.isWithinDistanceSquared(l.loc, 20) {
                        l.enemyDamage += 10;
                        existsDamage = true;
                    }

                }
            }
        }
    }
    for bot in Mem::nearbyEnemies {
        if bot.type.damage > 0 {
            existsDamage = true;
            if bot.mode.canAct {
                for loc in locs {
                    if loc != null {
                        // Assume they could move to attack us next turn, but give it a 2/3 chance
                        let d = bot.location.distanceSquaredTo(loc.loc);
                        // Assume they could move to attack us next turn, but give it a 2/3 chance
                        if d <= bot.type.actionRadiusSquared {
                            let rubble = rc.senseRubble(bot.location);
                            loc.enemyDamage += (bot.type.getDamage(bot.level) * 1000 / bot.type.actionCooldown) / (10 + rubble);
                        } else if bot.mode.canMove {
                            let towardsLoc = bot.location.add(bot.location.dirTo(loc.loc));
                            if towardsLoc.isWithinDistanceSquared(loc.loc, bot.type.actionRadiusSquared) {
                                let rubble = rc.senseRubble(bot.location.add(bot.location.dirTo(loc.loc)));
                                loc.enemyDamage += (bot.type.getDamage(bot.level) * 1000 / bot.type.actionCooldown) / (10 + rubble) * 2 / 3;
                            }
                        }
                    }
                }
            }
        }
    }
    for bot in Mem::nearbyAllies {
        if bot.type.isBuilding() {
            for l in locs {
                if l != null {
                    if bot.location.isWithinDistanceSquared(l.loc, RobotType::BUILDER.actionRadiusSquared) {
                        let v = Combat::repairValue(2, bot);
                        if v > l.repairValue {
                            l.repairTarget = bot;
                            l.repairValue = v;
                        }
                        if (bot.type == RobotType::WATCHTOWER || (bot.type == RobotType::LABORATORY && Mem::buildInfo.shouldUpgradeLab)) && bot.mode == RobotMode::TURRET && bot.level == 1 {
                            let rubble = rc.senseRubble(bot.location);
                            if rubble < towerRubble {
                                l.upgradeTarget = bot;
                                towerRubble = rubble;
                            }
                        }
                    }
                }
            }
        }
    }

    let best = cloc;
    for loc in locs {
        if loc != null {
            if locBetter(best, loc) {
                best = loc;
            }
        }
    }
    best
}

fn findSpawnSpace(): Direction throws GameActionException {
    let best = microLoc(false, true);

    if best != null {
        rc.getLocation().dirTo(best.loc)
    } else {
        let n: Direction = null;
        n
    }
}

let towerUpgrade: RobotInfo = null;
let bestRepair: RobotInfo = null;
fn microMove(): bool throws GameActionException {
    let best = microLoc(true, rc.isMovementReady());
    let at = rc.getLocation();

    if rc.isMovementReady() {
        if best != null && (Mem::nearbyEnemies.len() > 0 || best.repairValue > 0) {
            if best.loc != at {
                rc.setIndicatorString("MICRO MOVE: damage: " + best.enemyDamage + ", repair?: " + (best.repairTarget != null) + " v " + best.repairValue);
                rc.setIndicatorLine(at, best.loc, 0, 0, 255);
                rc.move(at.dirTo(best.loc));
            } else {
                rc.setIndicatorString("MICRO STAY: damage: " + best.enemyDamage + ", repair?: " + (best.repairTarget != null) + " v " + best.repairValue);
            }
            bestRepair = best.repairTarget;
            towerUpgrade = best.upgradeTarget;
            true
        } else {
            rc.setIndicatorString("NO MICRO: damage: " + cloc.enemyDamage + ", repair?: " + (cloc.repairTarget != null) + " v " + cloc.repairValue);
            bestRepair = cloc.repairTarget;
            towerUpgrade = cloc.upgradeTarget;
            false
        }
    } else {
        bestRepair = cloc.repairTarget;
        towerUpgrade = cloc.upgradeTarget;
        false
    }
}

fn turn() throws GameActionException {
    Mem::buildInfo.read();
    Mem::addBuilderCount();

    let loc = rc.getLocation();

    let canMove = !microMove();
    if bestRepair != null {
        if rc.canRepair(bestRepair.location) {
            rc.repair(bestRepair.location);
        }
    }

    if Mem::closestArchon != null && rc.canSenseLocation(Mem::closestArchon) {
        let robot = rc.senseRobotAtLocation(Mem::closestArchon);
        if robot != null && robot.health < robot.type.getMaxHealth(robot.level) {
            if rc.isMovementReady() && !robot.location.isWithinDistanceSquared(loc, RobotType::BUILDER.actionRadiusSquared) {
                Paths::target = robot.location;
                Paths::targetMove(false);
                return;
            }
        }
        if robot != null && robot.level == 1 && rc.canMutate(robot.location) {
            rc.mutate(robot.location);
            Mem::spend(RobotType::ARCHON.getLeadMutateCost(2));
        }
    }

    let cornerX = if loc.x <= rc.getMapWidth() / 2 { 0 } else { rc.getMapWidth() - 1 };
    let cornerY = if loc.y <= rc.getMapHeight() / 2 { 0 } else { rc.getMapHeight() - 1 };
    let corner = MapLocation(cornerX, cornerY);

    if bestRepair == null {
        if Mem::buildInfo.shouldBuildLab && Mem::nearbyEnemies.len() < 3 {
            let nearbyAllies = Mem::nearbyAllies.len();
            if (Mem::nearbyAllies.len() < 15 || corner.isAdjacentTo(loc)) {
                let best: Direction = null;
                let bestRubble = 10000;
                for dir in ALL_MOVE_DIRECTIONS {
                    if rc.canBuildRobot(RobotType::LABORATORY, dir) {
                        let rubble = rc.senseRubble(loc.add(dir));
                        if rubble < bestRubble {
                            bestRubble = rubble;
                            best = dir;
                        }
                    }
                }
                if best != null && bestRubble < 20 {
                    rc.buildRobot(RobotType::LABORATORY, best);
                    Mem::buildInfo.builtLab();
                    Mem::spend(RobotType::LABORATORY.buildCostLead);
                    Mem::addLabCount();
                } else if rc.senseRubble(rc.getLocation()) < 20 && rc.readSharedArray(Mem::LAB_CLAIM_LOC) == 0 {
                    rc.setIndicatorString("Waiting to build lab");
                    rc.writeSharedArray(Mem::LAB_CLAIM_LOC, 1);
                    return;
                }
            }
        } else if towerUpgrade != null && towerUpgrade.type == RobotType::LABORATORY && rc.getTeamLeadAmount(rc.getTeam()) >= RobotType::LABORATORY.buildCostLead && rc.canMutate(towerUpgrade.location) {
            rc.mutate(towerUpgrade.location);
            Mem::spend(towerUpgrade.type.getLeadMutateCost(towerUpgrade.level + 1));
            Mem::buildInfo.upgradedLab();
        } else if bytecodeLeft() > 3000 && existsDamage && Mem::buildInfo.shouldBuildWatchtower && rc.getTeamLeadAmount(rc.getTeam()) >= RobotType::WATCHTOWER.buildCostLead {
            if towerUpgrade != null && rc.canMutate(towerUpgrade.location) {
                rc.mutate(towerUpgrade.location);
                Mem::spend(towerUpgrade.type.getLeadMutateCost(towerUpgrade.level + 1));
                if towerUpgrade.type == RobotType::LABORATORY {
                    Mem::buildInfo.upgradedLab();
                }
            } else {
                let spot = Combat::microLoc(RobotType::WATCHTOWER, 1, true, true, RobotType::WATCHTOWER.health, false, false);
                if spot != null {
                    let dir = rc.getLocation().dirTo(spot.loc);
                    if spot.rubble < 40 && rc.canBuildRobot(RobotType::WATCHTOWER, dir) {
                        rc.buildRobot(RobotType::WATCHTOWER, dir);
                        Mem::buildInfo.builtWatchtower();
                        Mem::spend(RobotType::WATCHTOWER.buildCostLead);
                    }
                }
            }
        }

        if Mem::buildInfo.shouldFarmLead && Mem::closestArchon != null && loc.isWithinDistanceSquared(Mem::closestArchon, 20) {
            rc.setIndicatorString("SUICIDE MODE");
            // Sacrifice itself
            if rc.senseLead(loc) == 0 {
                Mem::buildInfo.farmedLead();
                Mem::buildInfo.writeBack();
                rc.disintegrate();
            } else {
                for dir in ALL_MOVE_DIRECTIONS {
                    let l = loc.add(dir);
                    if Mem::closestArchon.isWithinDistanceSquared(l, 13) && rc.canMove(dir) && rc.senseLead(l) == 0 {
                        rc.move(dir);
                        return;
                    }
                }
            }
        }
    }

    if canMove {
        if !Mem::buildInfo.shouldBuildLab && Mem::buildInfo.shouldBuildWatchtower {
            let closestSoldier = Mem::getClosestSoldier(rc.getLocation());
            if closestSoldier != null {
                Paths::target = closestSoldier;
            } else if Mem::enemyArchons.len() > 0 {
                let closest: MapLocation = null;
                let closest_d = 100000;
                for i in Mem::enemyArchons {
                    let d = i.distanceSquaredTo(rc.getLocation());
                    if d < closest_d {
                        closest = i;
                        closest_d = d;
                    }
                }
                if closest != null {
                    Paths::target = closest;
                }
            }
        } else if Mem::buildInfo.shouldBuildLab && rc.readSharedArray(Mem::LAB_CLAIM_LOC) == 0 {
            if rc.getID() % 2 == 0 {
                if !rc.canSenseLocation(corner) || rc.senseRubble(corner) <= 20 {
                    Paths::target = corner.add(corner.dirTo(loc));
                    Paths::targetMove(false);
                }
            }
        }
        Paths::targetMove(true);
    }

    Mem::buildInfo.writeBack();
}