extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

// What number archon this is, i.e. how many archons go before it each turn
let archonOrder = 0;
let archonCount = 0;
let START_MINERS: [i32] = [3, 4, 6, 7];

fn preTurn() throws GameActionException {

}

fn spawnMiner() throws GameActionException {
    if lead < RobotType::MINER.buildCostLead {
        return;
    }
    let dir = Miner::findSpawnSpace();
    if dir != null && rc.canBuildRobot(RobotType::MINER, dir) {
        Mem::addMinerCount();
        rc.buildRobot(RobotType::MINER, dir);
    }
}

fn spawnBuilder() throws GameActionException {
    if lead < RobotType::BUILDER.buildCostLead {
        return;
    }
    let dir = Builder::findSpawnSpace();
    if dir != null && rc.canBuildRobot(RobotType::BUILDER, dir) {
        Mem::addMinerCount();
        rc.buildRobot(RobotType::BUILDER, dir);
    }
}

fn spawnSuicideBuilder() throws GameActionException {
    if lead < RobotType::BUILDER.buildCostLead {
        return;
    }
    let best: Direction = null;
    let best_lead = 1000;
    for dir in ALL_MOVE_DIRECTIONS {
        if rc.canBuildRobot(RobotType::BUILDER, dir) {
            let lead = rc.senseLead(rc.getLocation().add(dir));
            if lead < best_lead {
                best = dir;
                best_lead = lead;
            }
        }
    }
    if best != null {
        rc.buildRobot(RobotType::BUILDER, best);
    }
}

fn spawnSoldier() throws GameActionException {
    if lead < RobotType::SOLDIER.buildCostLead {
        return;
    }
    let dir = Combat::findSpawnSpace(RobotType::SOLDIER);
    if dir != null && rc.canBuildRobot(RobotType::SOLDIER, dir) {
        Mem::addSoldierCount();
        rc.buildRobot(RobotType::SOLDIER, dir);
    }
}

fn spawnSage() throws GameActionException {
    let dir = Combat::findSpawnSpace(RobotType::SAGE);
    if dir != null && rc.canBuildRobot(RobotType::SAGE, dir) {
        rc.buildRobot(RobotType::SAGE, dir);
    }
}

let incomes: [i32] = [; 10];
let incomeIdx = 0;
fn averageIncome(): i32 throws GameActionException {
    let income = Mem::readIncome();
    incomes[incomeIdx] = income;
    incomeIdx = (incomeIdx + 1) % incomes.len();
    let sum = 0;
    for i in incomes {
        sum += i;
    }
    rc.setIndicatorString("Income this turn: " + income + ", average income: " + sum / incomes.len());
    sum / incomes.len()
}
let builderTurns = 0;
let lead = 0;
let canMove = true;
fn turn() throws GameActionException {
    if archonCount != rc.getArchonCount() {
        archonCount = rc.getArchonCount();
        archonOrder = rc.readSharedArray(0);
        if archonOrder == rc.getArchonCount() - 1 {
            rc.writeSharedArray(0, 0);
        } else {
            rc.writeSharedArray(0, archonOrder + 1);
        }
        rc.writeSharedArray(Mem::FRIENDLY_ARCHON_LOC + archonOrder, Mem::encodeLoc(rc.getLocation()));
    }

    if archonOrder == 0 {
        Mem::maintainMinerCorners();
        Mem::maintainSoldiers();
        Mem::resetIncome();
    }
    Mem::buildInfo.read();

    let minerCount = Mem::getMinerCount();
    let soldierCount = Mem::getSoldierCount();
    let income = averageIncome();
    lead = rc.getTeamLeadAmount(rc.getTeam());

    if rc.getMode() == RobotMode::PORTABLE {
        // Move to low rubble
        if Paths::archonMove() {
            rc.transform();
            canMove = true;
        }
    } else {
        if canMove && rc.canTransform() && minerCount >= START_MINERS[archonCount - 1] && rc.senseRubble(rc.getLocation()) > 0 {
            let rubble = rc.senseRubble(rc.getLocation());
            let found = false;
            for i in -5..6 {
                for j in unroll -5..6 {
                    let loc = rc.getLocation().translate(i, j);
                    if rc.canSenseLocation(loc) && rc.senseRubble(loc) < rubble {
                        found = true;
                    }
                }
                if found { break; }
            }
            if found {
                rc.transform();
            } else {
                canMove = false;
            }
        }

        // Normal archon things
        let needsBuilder = false;
        builderTurns += 1;
        if income >= 8
            && (Mem::buildInfo.shouldBuildWatchtower || Mem::buildInfo.shouldBuildLab || builderTurns >= 30)
            && minerCount > 3
            && Mem::nearbyEnemies.len() == 0
        {
            if Mem::getLabCount() == 0 {
                if builderTurns >= 30 && lead >= RobotType::BUILDER.buildCostLead {
                    builderTurns = 0;
                    needsBuilder = true;
                } else {
                    lead -= RobotType::LABORATORY.buildCostLead;
                }
                Mem::buildInfo.queueLab();
            } else {
                if builderTurns >= 30 && lead >= RobotType::BUILDER.buildCostLead {
                    builderTurns = 0;
                    needsBuilder = true;
                } else {
                    lead -= RobotType::WATCHTOWER.buildCostLead;
                }
                Mem::buildInfo.queueWatchtower();
            }
        } else if income >= 4 && (Mem::buildInfo.shouldBuildLab || Mem::buildInfo.shouldBuildWatchtower) {
            if Mem::buildInfo.shouldBuildLab {
                lead -= RobotType::LABORATORY.buildCostLead;
            } else {
                lead -= RobotType::WATCHTOWER.buildCostLead;
            }
        } else if income <= 3 && (Mem::buildInfo.shouldBuildWatchtower || Mem::buildInfo.shouldBuildLab) {
            Mem::buildInfo.builtWatchtower();
            Mem::buildInfo.builtLab();
        }

        // Don't let one Archon dominate
        // They take turns spawning, or they can override the order if there's enough for each other archon to spawn a soldier to defend itself
        if rc.getRoundNum() % rc.getArchonCount() == archonOrder
            || lead >= RobotType::MINER.buildCostLead * (rc.getArchonCount() - archonOrder) {
            let nLead = rc.senseNearbyLocationsWithLead(rc.getType().visionRadiusSquared, 1).len();
            let targetMinerCount = 6 + (rc.getMapWidth() + rc.getMapHeight())/20;
            let startMinerCount = START_MINERS[archonCount - 1];
            if needsBuilder {
                // rc.setIndicatorString("NORMAL BUILDER");
                spawnBuilder();
            } else if minerCount < targetMinerCount && (minerCount < startMinerCount || minerCount < soldierCount) {
                spawnMiner();
            } else if ((nLead < 20 && rc.getRoundNum() > 300)) && Mem::nearbyEnemies.len() < min(3, Mem::nearbyAllies.len()) {
                // This builder will suicide after possibly healing the archon
                // rc.setIndicatorString("SUICIDE BUILDER");
                Mem::buildInfo.queueLeadFarming();
                spawnSuicideBuilder();
            } else if rc.getTeamGoldAmount(rc.getTeam()) >= RobotType::SAGE.buildCostGold {
                spawnSage();
            } else {
                spawnSoldier();
            }
        }

        if rc.isActionReady() {
            // Try to repair a robot in range.
            // The targeting logic picks the most important and vulnerable unit,
            // so it works pretty well in this case too!
            let bestUnit: RobotInfo = null;
            let bestV = 0;
            Combat::at = rc.getLocation();
            let heal = rc.getType().getHealing(rc.getLevel());
            for i in Mem::nearbyAllies {
                if i.health < i.type.health && rc.canRepair(i.location) {
                    let v = Combat::repairValue(heal, i);
                    if v > bestV {
                        bestUnit = i;
                        bestV = v;
                    }
                }
            }
            if bestUnit != null {
                rc.repair(bestUnit.location);
            }
        }
    }

    let spent = lead - rc.getTeamLeadAmount(rc.getTeam());
    if spent > 0 {
        Mem::spend(spent);
    }
    if archonOrder == archonCount - 1 {
        Mem::clearMinerCount();
        Mem::clearSoldierCount();
        Mem::clearLabCount();
    }
    Mem::buildInfo.writeBack();
}