extern {
    import battlecode.common.*;
}

use Common::*;
use RobotPlayer::rc;

// Cache these, 200 bytecode is better than splitting it manually but we definitely don't want to do it twice
let nearbyAllies: [RobotInfo] = [];
let nearbyEnemies: [RobotInfo] = [];
let enemyArchons: [MapLocation] = [];
let friendlyArchons: [MapLocation] = [];
let lastFriendlyArchons = 0;
let closestArchon: MapLocation = null;

// 0: archon idx finding
// 1-5: enemy archon list
// 6:
// 7-8: miner corner stuff
// 9: miner count
// 10-13: friendly archon locations
define ARCHON_IDX_LOC = 0;
define ENEMY_ARCHON_LOC = 1;
define ENEMY_ARCHON_LEN = 6;
define MINER_CORNER_LOC = 7;
define MINER_COUNT_LOC = 9;
let FRIENDLY_ARCHON_LOC = 10;
define FRIENDLY_ARCHON_LEN = 4;

// A location takes up 12 bits
// ...this is a lot easier than last year
fn encodeLoc(loc: MapLocation): i32 = (loc.y << 6) | loc.x;
fn decodeLoc(x: i32): MapLocation = MapLocation(x & 0b111111, (x >> 6) & 0b111111);

// Run this once a turn, before doing other things.
// It caches nearby robots, communicates stuff it found, etc.
fn maintain() throws GameActionException {
    let loc = rc.getLocation();
    let visRadius = rc.getType().visionRadiusSquared;
    nearbyAllies = rc.senseNearbyRobotsT(visRadius, rc.getTeam());
    nearbyEnemies = rc.senseNearbyRobotsT(visRadius, rc.getTeam().opponent());

    if rc.getType() == RobotType::MINER {
        minerPassiveCornerSearch();
    }

    if lastFriendlyArchons != rc.getArchonCount() && (rc.getType() != RobotType::ARCHON || Archon::archonCount == rc.getArchonCount()) {
        lastFriendlyArchons = rc.getArchonCount();
        friendlyArchons.clear();
        for i in 0..rc.getArchonCount() {
            friendlyArchons.push(decodeLoc(rc.readSharedArray(FRIENDLY_ARCHON_LOC + 1)));
        }
    }
    let closestArchonD = 10000;
    for i in friendlyArchons {
        let d = i.distanceSquaredTo(loc);
        if d < closestArchonD {
            closestArchon = i;
            closestArchonD = d;
        }
    }

    readArchons();
    searchArchons();
}

fn registerArchon(index: i32, loc: MapLocation) throws GameActionException {
    rc.writeSharedArray(FRIENDLY_ARCHON_LOC + index, encodeLoc(loc));
}

// Miner corners structure:
// four corners, 8 bits each
// 6-bit distance to location, 1-bit ping, 1-bit has been found
let lastCheckIn: [i32; 4];
fn maintainMinerCorners() throws GameActionException {
    fn inline doCorner(info: i32, i: i32): i32 {
        if info == 0 || info & 1 != 0 {
            // nobody is going for it
            info
        } else if info & 0b10 == 0 {
            // someone is going for it and hasn't checked in yet
            // if it's been more than 2 turns, mark the corner as not having been found
            if lastCheckIn[i] <= rc.getRoundNum() - 2 {
                0
            } else {
                info
            }
        } else {
            // someone is going for it and they checked in
            lastCheckIn[i] = rc.getRoundNum();
            // so reset the ping
            info ^ 0b10
        }
    }

    let a = rc.readSharedArray(MINER_CORNER_LOC);
    let b = rc.readSharedArray(MINER_CORNER_LOC + 1);
    let a2 = doCorner(a & 0b111111, 0) | (doCorner(a >> 8, 1) << 8);
    let b2 = doCorner(b & 0b111111, 2) | (doCorner(b >> 8, 3) << 8);
    if a != a2 {
        rc.writeSharedArray(MINER_CORNER_LOC, a2);
    }
    if b != b2 {
        rc.writeSharedArray(MINER_CORNER_LOC + 1, b2);
    }
}
let cornerLocs: [MapLocation] = [];
fn minerPingCorner(i: i32): bool throws GameActionException {
    let idx = MINER_CORNER_LOC + i / 2;
    let a = rc.readSharedArray(idx);
    if a & (1 << (8 * (i % 2))) != 0 {
        false
    } else {
        a |= (0b10 << 8 * (i % 2));
        rc.writeSharedArray(idx, a);
        true
    }
}
fn minerClaimCorner(): i32 throws GameActionException {
    fn inline tryCorner(i: i32): bool {
        let idx = MINER_CORNER_LOC + i / 2;
        let a = rc.readSharedArray(idx);
        let b = if i % 2 == 0 {
            a & 0b111111
        } else {
            a >> 8
        };
        if b == 0 {
            let loc = cornerLocs[i];
            let at = rc.getLocation();
            if abs(loc.x - at.x) <= rc.getMapWidth() / 2 && abs(loc.y - at.y) <= rc.getMapHeight() / 2 {
                let d = max(abs(loc.x - at.x), abs(loc.y - at.y));
                a |= ((d << 2) | 0b10) << (8 * (i % 2));
                rc.writeSharedArray(idx, a);
                true
            } else {
                false
            }
        } else {
            false
        }
    }

    for i in unroll 0..4 {
        if tryCorner(i) {
            return i;
        }
    }

    -1
}
fn minerPassiveCornerSearch() throws GameActionException {
    if cornerLocs.len() == 0 {
        cornerLocs.push(MapLocation(0, 0));
        cornerLocs.push(MapLocation(0, rc.getMapHeight() - 1));
        cornerLocs.push(MapLocation(rc.getMapWidth() - 1, 0));
        cornerLocs.push(MapLocation(rc.getMapWidth() - 1, rc.getMapHeight() - 1));
    }
    for i in unroll 0..4 {
        if rc.canSenseLocation(cornerLocs[i]) {
            let idx = MINER_CORNER_LOC + i / 2;
            let a = rc.readSharedArray(idx);
            let bit = (1 << 8 * (i % 2));
            if a & bit == 0 {
                a |= bit;
                rc.writeSharedArray(idx, a);
            }
        }
    }
}

fn getMinerCount(): i32 throws GameActionException {
    rc.readSharedArray(MINER_COUNT_LOC)
}
fn clearMinerCount() throws GameActionException {
    rc.writeSharedArray(MINER_COUNT_LOC, 0);
}
fn addMinerCount() throws GameActionException {
    rc.writeSharedArray(MINER_COUNT_LOC, rc.readSharedArray(MINER_COUNT_LOC) + 1);
}

fn readArchons() throws GameActionException {
    let a = rc.readSharedArray(ENEMY_ARCHON_LOC);
    // 4-bit number of enemy archons we know of
    let numArchons = a >> 12;
    if numArchons != enemyArchons.len() {
        enemyArchons.clear();
        for i in 0..numArchons {
            let n = rc.readSharedArray(ENEMY_ARCHON_LOC + i);
            enemyArchons.push(decodeLoc(n));
        }
    }
}
fn pushArchon(loc: MapLocation) throws GameActionException {
    if enemyArchons.len() >= ENEMY_ARCHON_LEN {
        return;
    }

    rc.setIndicatorLine(rc.getLocation(), loc, 255, 0, 0);

    enemyArchons.push(loc);
    let a = rc.readSharedArray(ENEMY_ARCHON_LOC);
    let oldNum = a >> 12;
    // Don't incur the 100 btc cost twice unless we need to
    if oldNum == 0 {
        let a = ((oldNum + 1) << 12) | encodeLoc(loc);
        rc.writeSharedArray(ENEMY_ARCHON_LOC, a);
    } else {
        // Just do the addition on the high bits directly
        a += 1 << 12;
        rc.writeSharedArray(ENEMY_ARCHON_LOC, a);
        rc.writeSharedArray(ENEMY_ARCHON_LOC + oldNum, encodeLoc(loc));
    }
}
fn removeArchon(i: i32) throws GameActionException {
    rc.setIndicatorLine(rc.getLocation(), enemyArchons[i], 127, 0, 127);

    // Easy case
    if enemyArchons.len() == 1 {
        let _ = enemyArchons.pop();
        rc.writeSharedArray(ENEMY_ARCHON_LOC, 0);
        return;
    }

    // Swap the removed element with the last element so only touch those two
    // (and we don't even have to touch the last element in the shared array)
    let last_loc = enemyArchons.pop();
    if i != enemyArchons.len() {
        enemyArchons[i] = last_loc;
    }
    if i == 0 {
        rc.writeSharedArray(ENEMY_ARCHON_LOC, (enemyArchons.len() << 12) | encodeLoc(last_loc));
    } else {
        let a = rc.readSharedArray(ENEMY_ARCHON_LOC);
        a -= 1 << 12;
        rc.writeSharedArray(ENEMY_ARCHON_LOC, a);
        rc.writeSharedArray(ENEMY_ARCHON_LOC + i, encodeLoc(last_loc));
    }
}
fn searchArchons() throws GameActionException {
    fn seenArchon(loc: MapLocation): bool {
        for i in enemyArchons {
            if i == loc {
                return true;
            }
        }
        false
    }

    // Find new archons
    for i in nearbyEnemies {
        if i.type == RobotType::ARCHON && i.mode == RobotMode::TURRET && !seenArchon(i.location) {
            pushArchon(i.location);
        }
    }
    // Remove ones that no longer exist
    let remove: [i32] = [];
    for i in 0..enemyArchons.len() {
        if enemyArchons[i].isWithinDistanceSquared(rc.getLocation(), rc.getType().visionRadiusSquared) {
            let r = rc.senseRobotAtLocation(enemyArchons[i]);
            if r == null || r.type != RobotType::ARCHON {
                remove.push(i);
            }
        }
    }
    for i in remove {
        removeArchon(i);
    }
}